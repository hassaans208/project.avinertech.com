# MySQL Database Management API - Laravel Implementation Guide

## Table of Contents
1. [Implementation Overview](#implementation-overview)
2. [P0 Critical Implementation Tasks](#p0-critical-implementation-tasks)
3. [P1 High-Value Implementation Tasks](#p1-high-value-implementation-tasks)
4. [Tenant-Based Operation System](#tenant-based-operation-system)
5. [Batch Processing with Admin Approval](#batch-processing-with-admin-approval)
6. [Instant Data Operations](#instant-data-operations)
7. [Signature Verification System](#signature-verification-system)
8. [Soft Delete System](#soft-delete-system)
9. [Laravel Architecture & Structure](#laravel-architecture--structure)
10. [Security Implementation](#security-implementation)
11. [API Versioning & Job Management](#api-versioning--job-management)
12. [Database Configuration](#database-configuration)
13. [Service Layer Implementation](#service-layer-implementation)
14. [Controller Implementation](#controller-implementation)
15. [Middleware Implementation](#middleware-implementation)
16. [Validation & Error Handling](#validation--error-handling)
17. [Testing Strategy](#testing-strategy)
18. [Deployment Checklist](#deployment-checklist)

---

## Implementation Overview

This implementation guide addresses the critical recommendations from the executive summary while building upon the comprehensive API documentation. The implementation follows a **tenant-based, security-first approach** with **admin approval workflows** for batch operations and **instant execution** for data operations.

### Key Implementation Principles
- **Tenant-based operations** with signature verification
- **Admin approval workflow** for batch operations (DDL)
- **Instant execution** for data operations (CRUD)
- **Auto-generated operation naming** system
- **Global soft delete** implementation
- **Tenant blocking** for security violations
- **Server-side security enforcement** (deny/allow lists)
- **API versioning** (`/api/v1/database/`)
- **Idempotency** for all mutating operations
- **Job-based DDL handling** with status tracking
- **Preflight vs Apply** separation
- **MySQL capability matrix** validation
- **Least-privilege database user**

### Operation Cases Architecture

The system supports three distinct operational modes:

1. **Case 1: Fresh App DB** - Batch mode with admin approval
2. **Case 2: Modify/Enhance App DB** - Batch mode with admin approval  
3. **Case 3: Data Operations** - Instant execution mode

### Auto-Generated Operation Naming

```
BATCH Operations:
- CREATE: BATCH{number}_CREATE_{tablename}_TABLE
- ALTER: BATCH{number}_ALTER_{tablename}_TABLE
- DROP: BATCH{number}_DROP_{tablename}_TABLE (blocked but logged)

INSTANT Operations:
- SELECT: INSTANT_SELECT_{tablename}_WITH/WITHOUT_FILTERS
- INSERT: INSTANT_INSERT_{tablename}_RECORD
- UPDATE: INSTANT_UPDATE_{tablename}_RECORD
- DELETE: INSTANT_DELETE_{tablename}_RECORD (soft delete)
```

---

## P0 Critical Implementation Tasks

### 1. Security Middleware Implementation

#### SecurityMiddleware.php
```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;

class SecurityMiddleware
{
    private const DENY_LIST = [
        'DROP DATABASE', 'DROP TABLE', 'DROP USER', 'DROP VIEW', 
        'DROP TRIGGER', 'DROP EVENT', 'DROP FUNCTION', 'DROP PROCEDURE',
        'GRANT', 'REVOKE', 'CREATE USER', 'ALTER DATABASE', 
        'KILL', 'SHUTDOWN', 'FLUSH', 'RESET'
    ];

    private const ALLOW_LIST = [
        'CREATE TABLE', 'ALTER TABLE', 'CREATE VIEW', 'ALTER VIEW',
        'CREATE TRIGGER', 'ALTER TRIGGER', 'CREATE PROCEDURE', 'ALTER PROCEDURE',
        'CREATE FUNCTION', 'ALTER FUNCTION', 'CREATE EVENT', 'ALTER EVENT',
        'CREATE INDEX', 'DROP INDEX', 'INSERT', 'UPDATE', 'DELETE', 'SELECT'
    ];

    public function handle(Request $request, Closure $next)
    {
        // Only apply to database API routes
        if (!$request->is('api/v1/database/*')) {
            return $next($request);
        }

        // Skip for preview-only endpoints
        if ($request->is('api/v1/database/preview-sql')) {
            return $next($request);
        }

        // Extract SQL from request (generated by SqlGeneratorService)
        $sql = $request->input('generated_sql') ?? $request->input('sql');
        
        if ($sql) {
            $this->validateSql($sql, $request);
        }

        return $next($request);
    }

    private function validateSql(string $sql, Request $request): void
    {
        $sqlUpper = strtoupper(trim($sql));
        
        // Check deny list
        foreach (self::DENY_LIST as $denied) {
            if (strpos($sqlUpper, $denied) !== false) {
                Log::warning('Blocked dangerous SQL', [
                    'sql' => $sql,
                    'user_id' => auth()->id(),
                    'ip' => $request->ip(),
                    'user_agent' => $request->userAgent()
                ]);
                
                abort(403, 'OPERATION_NOT_PERMITTED: ' . $denied . ' operations are not allowed');
            }
        }

        // Validate against allow list for DDL operations
        if ($this->isDdlOperation($sqlUpper)) {
            $allowed = false;
            foreach (self::ALLOW_LIST as $allowedOp) {
                if (strpos($sqlUpper, $allowedOp) !== false) {
                    $allowed = true;
                    break;
                }
            }
            
            if (!$allowed) {
                Log::warning('Blocked non-whitelisted DDL', [
                    'sql' => $sql,
                    'user_id' => auth()->id()
                ]);
                
                abort(403, 'OPERATION_NOT_PERMITTED: DDL operation not in allow list');
            }
        }
    }

    private function isDdlOperation(string $sql): bool
    {
        $ddlKeywords = ['CREATE', 'ALTER', 'DROP', 'TRUNCATE'];
        foreach ($ddlKeywords as $keyword) {
            if (strpos($sql, $keyword) === 0) {
                return true;
            }
        }
        return false;
    }
}
```

### 2. Database User Configuration

#### config/database.php (Addition)
```php
<?php

return [
    // ... existing config ...

    'connections' => [
        // ... existing connections ...

        'ui_api' => [
            'driver' => 'mysql',
            'host' => env('UI_API_DB_HOST', '127.0.0.1'),
            'port' => env('UI_API_DB_PORT', '3306'),
            'database' => env('UI_API_DB_DATABASE', ''),
            'username' => env('UI_API_DB_USERNAME', 'ui_api'),
            'password' => env('UI_API_DB_PASSWORD', ''),
            'charset' => 'utf8mb4',
            'collation' => 'utf8mb4_0900_ai_ci',
            'prefix' => '',
            'strict' => true,
            'engine' => null,
            'options' => [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            ],
        ],
    ],
];
```

#### Database User Setup SQL
```sql
-- Create least-privilege user for UI API
CREATE USER 'ui_api'@'%' IDENTIFIED BY 'secure_password_here';

-- Grant only necessary privileges (NO DROP, NO GRANT OPTION)
GRANT SELECT, INSERT, UPDATE, DELETE,
      CREATE, ALTER, INDEX, REFERENCES,
      CREATE VIEW, SHOW VIEW,
      CREATE ROUTINE, ALTER ROUTINE, EXECUTE,
      EVENT, TRIGGER
ON *.* TO 'ui_api'@'%';

-- Flush privileges
FLUSH PRIVILEGES;
```

### 3. Enhanced API Routes with Tenant Support

#### routes/api.php
```php
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\Api\V1\DatabaseController;
use App\Http\Controllers\Api\V1\SchemaController;
use App\Http\Controllers\Api\V1\TableController;
use App\Http\Controllers\Api\V1\OperationController;
use App\Http\Controllers\Api\V1\AdminController;

// API v1 Database routes with tenant support
Route::prefix('api/v1/database')->middleware([
    'signature-verification', 
    'tenant-security', 
    'idempotency'
])->group(function () {
    
    // Capability probe
    Route::get('/capabilities', [DatabaseController::class, 'capabilities']);
    
    // Schema management
    Route::get('/schemas', [SchemaController::class, 'index']);
    Route::get('/schemas/{schemaName}', [SchemaController::class, 'show']);
    
    // Table management (Batch operations - require approval)
    Route::get('/schemas/{schemaName}/tables', [TableController::class, 'index']);
    Route::get('/schemas/{schemaName}/tables/{tableName}', [TableController::class, 'show']);
    Route::post('/schemas/{schemaName}/tables', [TableController::class, 'store']); // Batch
    Route::patch('/schemas/{schemaName}/tables/{tableName}', [TableController::class, 'update']); // Batch
    
    // Column management (Batch operations)
    Route::post('/schemas/{schemaName}/tables/{tableName}/columns', [TableController::class, 'addColumn']); // Batch
    Route::patch('/schemas/{schemaName}/tables/{tableName}/columns/{columnName}', [TableController::class, 'updateColumn']); // Batch
    Route::delete('/schemas/{schemaName}/tables/{tableName}/columns/{columnName}', [TableController::class, 'deleteColumn']); // Batch
    
    // Index management (Batch operations)
    Route::post('/schemas/{schemaName}/tables/{tableName}/indexes', [TableController::class, 'addIndex']); // Batch
    Route::patch('/schemas/{schemaName}/tables/{tableName}/indexes/{indexName}', [TableController::class, 'updateIndex']); // Batch
    Route::delete('/schemas/{schemaName}/tables/{tableName}/indexes/{indexName}', [TableController::class, 'deleteIndex']); // Batch
    
    // Foreign key management (Batch operations)
    Route::post('/schemas/{schemaName}/tables/{tableName}/foreign-keys', [TableController::class, 'addForeignKey']); // Batch
    Route::patch('/schemas/{schemaName}/tables/{tableName}/foreign-keys/{constraintName}', [TableController::class, 'updateForeignKey']); // Batch
    Route::delete('/schemas/{schemaName}/tables/{tableName}/foreign-keys/{constraintName}', [TableController::class, 'deleteForeignKey']); // Batch
    
    // Check constraints (Batch operations)
    Route::post('/schemas/{schemaName}/tables/{tableName}/checks', [TableController::class, 'addCheck']); // Batch
    Route::patch('/schemas/{schemaName}/tables/{tableName}/checks/{constraintName}', [TableController::class, 'updateCheck']); // Batch
    Route::delete('/schemas/{schemaName}/tables/{tableName}/checks/{constraintName}', [TableController::class, 'deleteCheck']); // Batch
    
    // Partitioning (Batch operations)
    Route::post('/schemas/{schemaName}/tables/{tableName}/partitions', [TableController::class, 'enablePartitioning']); // Batch
    Route::post('/schemas/{schemaName}/tables/{tableName}/partitions/add', [TableController::class, 'addPartition']); // Batch
    Route::post('/schemas/{schemaName}/tables/{tableName}/partitions/reorganize', [TableController::class, 'reorganizePartitions']); // Batch
    
    // Data management (Instant operations)
    Route::get('/schemas/{schemaName}/tables/{tableName}/data', [TableController::class, 'getData']); // Instant
    Route::post('/schemas/{schemaName}/tables/{tableName}/data', [TableController::class, 'insertData']); // Instant
    Route::patch('/schemas/{schemaName}/tables/{tableName}/data/{rowId}', [TableController::class, 'updateData']); // Instant
    Route::delete('/schemas/{schemaName}/tables/{tableName}/data/{rowId}', [TableController::class, 'deleteData']); // Instant (soft delete)
    
    // Soft delete management
    Route::get('/schemas/{schemaName}/tables/{tableName}/soft-deleted', [TableController::class, 'getSoftDeleted']); // Instant
    Route::post('/schemas/{schemaName}/tables/{tableName}/soft-deleted/{recordId}/recover', [TableController::class, 'recoverRecord']); // Instant
    Route::delete('/schemas/{schemaName}/tables/{tableName}/soft-deleted/{recordId}/permanent', [TableController::class, 'permanentlyDeleteRecord']); // Instant
    
    // Metadata APIs (cached on frontend)
    Route::get('/metadata/filters', [MetadataController::class, 'getFilters']); // Get all filter operators
    Route::get('/metadata/aggregations', [MetadataController::class, 'getAggregations']); // Get all aggregation functions
    Route::get('/metadata/columns', [MetadataController::class, 'getAllColumns']); // Get all tenant table columns
    
    // Raw Query API (strict validation)
    Route::post('/raw-query', [RawQueryController::class, 'execute']); // Execute validated raw SELECT queries
    
    // SQL Preview (never executes)
    Route::post('/preview-sql', [DatabaseController::class, 'previewSql']);
    
    // Operations (job-based DDL)
    Route::post('/operations', [OperationController::class, 'create']);
    Route::get('/operations/{operationId}', [OperationController::class, 'show']);
    Route::get('/operations', [OperationController::class, 'index']);
    
    // Operation Groups (batch management)
    Route::get('/operation-groups', [OperationController::class, 'getGroups']);
    Route::post('/operation-groups/{groupId}/request-approval', [OperationController::class, 'requestApproval']);
    Route::get('/operation-groups/{groupId}', [OperationController::class, 'getGroup']);
});

// Admin routes (separate middleware for admin operations)
Route::prefix('api/v1/admin')->middleware([
    'auth:sanctum',
    'admin'
])->group(function () {
    
    // Admin approval operations
    Route::post('/operation-groups/{groupId}/approve', [AdminController::class, 'approveBatch']);
    Route::post('/operation-groups/{groupId}/reject', [AdminController::class, 'rejectBatch']);
    Route::get('/operation-groups/pending', [AdminController::class, 'getPendingBatches']);
    
    // Tenant management
    Route::get('/tenants/{tenantId}/security-logs', [AdminController::class, 'getTenantSecurityLogs']);
    Route::post('/tenants/{tenantId}/unblock', [AdminController::class, 'unblockTenant']);
    Route::get('/tenants/blocked', [AdminController::class, 'getBlockedTenants']);
    
    // System monitoring
    Route::get('/operations/stats', [AdminController::class, 'getOperationStats']);
    Route::get('/system/health', [AdminController::class, 'getSystemHealth']);
});
```

### 4. Capability Matrix Implementation

#### DatabaseController.php (Capabilities Method)
```php
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class DatabaseController extends Controller
{
    public function capabilities(Request $request)
    {
        try {
            $version = DB::connection('ui_api')->select('SELECT VERSION() as version')[0]->version;
            $versionNumber = $this->extractVersionNumber($version);
            
            return response()->json([
                'success' => true,
                'data' => [
                    'version' => $version,
                    'version_number' => $versionNumber,
                    'capabilities' => [
                        'functional_indexes' => $versionNumber >= 80013,
                        'check_constraints_enforced' => $versionNumber >= 80000,
                        'invisible_indexes' => $versionNumber >= 80000,
                        'generated_columns' => $versionNumber >= 57000,
                        'json_type' => $versionNumber >= 57000,
                        'spatial_indexes' => true, // InnoDB supports this
                        'partitioning' => true,
                        'deprecated_display_widths' => $versionNumber < 80000,
                        'zerofill_attribute' => $versionNumber < 80000,
                    ],
                    'limits' => [
                        'max_index_length' => 3072, // utf8mb4 bytes
                        'max_varchar_length' => 65535,
                        'max_decimal_precision' => 65,
                        'max_decimal_scale' => 30,
                        'max_enum_values' => 65535,
                    ],
                    'engines' => $this->getAvailableEngines(),
                ],
                'timestamp' => now()->toISOString(),
                'request_id' => $request->header('X-Request-ID', uniqid())
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'error' => [
                    'code' => 'CAPABILITY_PROBE_FAILED',
                    'message' => 'Failed to probe database capabilities',
                    'details' => $e->getMessage()
                ],
                'timestamp' => now()->toISOString(),
                'request_id' => $request->header('X-Request-ID', uniqid())
            ], 500);
        }
    }

    private function extractVersionNumber(string $version): int
    {
        preg_match('/(\d+)\.(\d+)\.(\d+)/', $version, $matches);
        return (int)($matches[1] . str_pad($matches[2], 2, '0', STR_PAD_LEFT) . str_pad($matches[3], 2, '0', STR_PAD_LEFT));
    }

    private function getAvailableEngines(): array
    {
        $engines = DB::connection('ui_api')->select('SHOW ENGINES');
        return array_map(fn($engine) => $engine->Engine, $engines);
    }
}
```

---

## Tenant-Based Operation System

### Database Schema for Tenant Operations

```sql
-- Operation Cases Table
CREATE TABLE operation_cases (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    execution_mode ENUM('batch', 'instant') NOT NULL,
    requires_approval BOOLEAN DEFAULT FALSE,
    max_batch_size INT DEFAULT 50,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Operation Groups (for batch processing)
CREATE TABLE operation_groups (
    id VARCHAR(36) PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    case_id VARCHAR(36) NOT NULL,
    name VARCHAR(100) NOT NULL,
    status ENUM('draft', 'pending_approval', 'approved', 'queued', 'running', 'completed', 'failed', 'cancelled') DEFAULT 'draft',
    approval_requested_at TIMESTAMP NULL,
    approved_at TIMESTAMP NULL,
    approved_by BIGINT UNSIGNED NULL,
    started_at TIMESTAMP NULL,
    completed_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (case_id) REFERENCES operation_cases(id),
    FOREIGN KEY (approved_by) REFERENCES users(id)
);

-- Enhanced Operations Table with Tenant Support
CREATE TABLE operations (
    id VARCHAR(36) PRIMARY KEY,
    group_id VARCHAR(36) NULL, -- NULL for instant operations
    tenant_id VARCHAR(36) NOT NULL, -- From signature
    case_id VARCHAR(36) NOT NULL,
    type VARCHAR(50) NOT NULL,
    name VARCHAR(100) NOT NULL, -- Auto-generated
    schema_name VARCHAR(64) NOT NULL,
    table_name VARCHAR(64) NULL,
    payload JSON NOT NULL,
    sql_preview TEXT NOT NULL,
    status ENUM('draft', 'pending_approval', 'queued', 'running', 'success', 'failed', 'cancelled') DEFAULT 'draft',
    execution_order INT DEFAULT 0,
    result JSON NULL,
    error_message TEXT NULL,
    started_at TIMESTAMP NULL,
    completed_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (group_id) REFERENCES operation_groups(id),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id), -- Existing tenant table
    FOREIGN KEY (case_id) REFERENCES operation_cases(id)
);

-- Tenant Blocking System
CREATE TABLE tenant_security_logs (
    id VARCHAR(36) PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    operation_type VARCHAR(50) NOT NULL,
    denied_query TEXT NOT NULL,
    reason VARCHAR(255) NOT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

-- Soft Delete Management
CREATE TABLE soft_delete_logs (
    id VARCHAR(36) PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    table_name VARCHAR(64) NOT NULL,
    record_id VARCHAR(36) NOT NULL,
    original_data JSON NOT NULL,
    deleted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_by VARCHAR(36) NOT NULL, -- User/tenant who deleted
    signature VARCHAR(255) NOT NULL,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

-- Dynamic Query Limits Configuration
CREATE TABLE query_limits (
    id INT PRIMARY KEY AUTO_INCREMENT,
    case_id VARCHAR(36) NOT NULL,
    operation_type VARCHAR(50) NOT NULL,
    max_columns_threshold INT DEFAULT 3,
    max_records_small_table INT DEFAULT 1000,
    max_records_large_table INT DEFAULT 100,
    soft_delete_enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (case_id) REFERENCES operation_cases(id),
    UNIQUE KEY unique_case_operation (case_id, operation_type)
);

-- Signature Verification Log
CREATE TABLE signature_verifications (
    id VARCHAR(36) PRIMARY KEY,
    operation_id VARCHAR(36) NOT NULL,
    signature VARCHAR(255) NOT NULL,
    verification_status ENUM('pending', 'verified', 'failed') DEFAULT 'pending',
    verification_response JSON NULL,
    verified_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (operation_id) REFERENCES operations(id)
);
```

### Tenant-Based Service Architecture

```php
// Tenant-Aware Operation Processor
class TenantOperationProcessor
{
    public function __construct(
        private SignatureVerificationService $signatureService,
        private TenantSecurityService $securityService,
        private OperationNamingService $namingService,
        private SoftDeleteService $softDeleteService,
        private OperationHandlerFactory $handlerFactory
    ) {}

    public function processOperation(array $requestData): OperationResult
    {
        // 1. Verify signature and extract tenant
        $tenant = $this->signatureService->verifyAndExtractTenant($requestData['signature']);
        
        // 2. Check tenant security status
        $this->securityService->validateTenantAccess($tenant);
        
        // 3. Generate operation name
        $operationName = $this->namingService->generateName($requestData, $tenant);
        
        // 4. Process based on operation case
        return $this->routeOperation($requestData, $tenant, $operationName);
    }

    private function routeOperation(array $requestData, Tenant $tenant, string $operationName): OperationResult
    {
        $operationType = $requestData['type'];
        $handler = $this->handlerFactory->getHandler($operationType);
        
        if ($handler instanceof BatchProcessorInterface) {
            return $this->processBatchOperation($requestData, $tenant, $operationName, $handler);
        }
        
        if ($handler instanceof InstantProcessorInterface) {
            return $this->processInstantOperation($requestData, $tenant, $operationName, $handler);
        }
        
        throw new UnsupportedOperationException("No suitable processor for operation type: {$operationType}");
    }
}
```

---

## Batch Processing with Admin Approval

### Admin Approval Workflow

```php
// Admin Approval Service
class AdminApprovalService
{
    public function __construct(
        private OperationGroupRepository $groupRepository,
        private NotificationService $notificationService,
        private AuditService $auditService
    ) {}

    public function approveBatch(string $groupId, string $adminId): void
    {
        $group = $this->groupRepository->findOrFail($groupId);
        
        // Validate admin permissions
        $this->validateAdminPermissions($adminId, $group);
        
        // Update operation group status
        $group->update([
            'status' => 'approved',
            'approved_at' => now(),
            'approved_by' => $adminId
        ]);
        
        // Queue batch for processing
        ProcessBatchOperation::dispatch($group);
        
        // Log approval action
        $this->auditService->logApproval($group, $adminId);
        
        // Notify tenant
        $this->notificationService->notifyTenantBatchApproved($group);
    }
    
    public function rejectBatch(string $groupId, string $adminId, string $reason): void
    {
        $group = $this->groupRepository->findOrFail($groupId);
        
        // Update operation group status
        $group->update([
            'status' => 'cancelled',
            'rejection_reason' => $reason,
            'rejected_by' => $adminId,
            'rejected_at' => now()
        ]);
        
        // Log rejection with reason
        $this->auditService->logRejection($group, $adminId, $reason);
        
        // Notify tenant of rejection
        $this->notificationService->notifyTenantBatchRejected($group, $reason);
    }
    
    private function validateAdminPermissions(string $adminId, OperationGroup $group): void
    {
        // Check if admin has permission to approve operations for this tenant
        // Implementation depends on your admin permission system
    }
}
```

### Batch Operation Processing Job

```php
// Process Batch Operation Job
class ProcessBatchOperation implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 1800; // 30 minutes
    public $tries = 3;

    protected $operationGroup;

    public function __construct(OperationGroup $operationGroup)
    {
        $this->operationGroup = $operationGroup;
    }

    public function handle()
    {
        $this->operationGroup->update([
            'status' => 'running',
            'started_at' => now()
        ]);

        try {
            DB::connection('ui_api')->beginTransaction();
            
            // Process operations in order
            $operations = $this->operationGroup->operations()
                ->orderBy('execution_order')
                ->get();
                
            foreach ($operations as $operation) {
                $this->processOperation($operation);
            }
            
            DB::connection('ui_api')->commit();
            
            $this->operationGroup->update([
                'status' => 'completed',
                'completed_at' => now()
            ]);

        } catch (\Exception $e) {
            DB::connection('ui_api')->rollBack();
            
            $this->operationGroup->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
                'completed_at' => now()
            ]);

            throw $e;
        }
    }

    private function processOperation(Operation $operation): void
    {
        $operation->update(['status' => 'running', 'started_at' => now()]);
        
        try {
            // Execute the SQL
            $result = DB::connection('ui_api')->statement($operation->sql_preview);
            
            $operation->update([
                'status' => 'success',
                'result' => ['executed' => true],
                'completed_at' => now()
            ]);
            
        } catch (\Exception $e) {
            $operation->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
                'completed_at' => now()
            ]);
            
            throw $e;
        }
    }
}
```

---

## Instant Data Operations

### Instant Operation Processing

```php
// Instant Data Operation Handler
class DataQueryHandler implements OperationHandlerInterface, InstantProcessorInterface
{
    public function __construct(
        private QueryLimitsService $limitsService,
        private SoftDeleteService $softDeleteService
    ) {}

    public function canHandle(string $operationType): bool
    {
        return in_array($operationType, ['select', 'insert', 'update', 'delete']);
    }
    
    public function processInstant(Operation $operation): OperationResult
    {
        $limits = $this->getQueryLimits($operation);
        
        switch ($operation->type) {
            case 'select':
                return $this->processSelect($operation, $limits);
            case 'insert':
                return $this->processInsert($operation);
            case 'update':
                return $this->processUpdate($operation);
            case 'delete':
                return $this->processSoftDelete($operation);
        }
    }
    
    private function processSelect(Operation $operation, QueryLimits $limits): OperationResult
    {
        $sql = $operation->sql_preview;
        
        // Enforce limits
        if ($limits->hasFilters($sql)) {
            $sql .= " LIMIT {$limits->max_records_with_filters}";
        } else {
            $sql .= " LIMIT {$limits->max_records_without_filters}";
        }
        
        $results = DB::connection('ui_api')->select($sql);
        
        return new OperationResult([
            'success' => true,
            'data' => $results,
            'count' => count($results),
            'limited' => count($results) >= $limits->max_records_without_filters
        ]);
    }
    
    private function processSoftDelete(Operation $operation): OperationResult
    {
        // Extract record ID and table name from SQL
        $recordId = $this->extractRecordId($operation->sql_preview);
        $tableName = $operation->table_name;
        
        // Get original data before soft delete
        $originalData = DB::connection('ui_api')
            ->table($tableName)
            ->where('id', $recordId)
            ->first();
            
        // Perform soft delete (add deleted_at timestamp)
        DB::connection('ui_api')
            ->table($tableName)
            ->where('id', $recordId)
            ->update([
                'deleted_at' => now(),
                'deleted_by' => $operation->tenant_id
            ]);
            
        // Log soft delete
        $this->softDeleteService->logSoftDelete(
            $operation->tenant_id,
            $tableName,
            $recordId,
            $originalData,
            $operation->payload['signature']
        );
        
        return new OperationResult([
            'success' => true,
            'message' => 'Record soft deleted successfully',
            'record_id' => $recordId
        ]);
    }
    
    public function getQueryLimits(Operation $operation): QueryLimits
    {
        return $this->limitsService->getLimitsForOperation($operation);
    }
}
```

---

## Signature Verification System

### Signature Verification Service

```php
// Signature Verification Service
class SignatureVerificationService
{
    public function __construct(
        private HttpClient $httpClient,
        private CacheManager $cache
    ) {}

    public function verifyAndExtractTenant(string $signature): string
    {
        // Check cache first
        $cacheKey = 'signature_verification:' . hash('sha256', $signature);
        $cachedResult = $this->cache->get($cacheKey);
        
        if ($cachedResult) {
            return $cachedResult['tenant_id'];
        }
        
        try {
            // Call signal service to verify signature
            $response = $this->httpClient->post('https://signal.avinertech.com/api/signature/verify', [
                'headers' => [
                    'X-APP-SIGNATURE' => $signature,
                    'Content-Type' => 'application/json'
                ]
            ]);
            
            if ($response->status() === 404) {
                throw new SignatureVerificationException('Invalid signature or tenant blocked');
            }
            
            if ($response->status() !== 200) {
                throw new SignatureVerificationException('Signature verification failed');
            }
            
            $responseData = $response->json();
            $tenantId = $responseData['tenantId'] ?? $responseData['tenant_id'];
            
            // Cache result for 1 hour
            $this->cache->put($cacheKey, [
                'tenant_id' => $tenantId,
                'verified_at' => now()
            ], 3600);
            
            return $tenantId;
            
        } catch (\Exception $e) {
            Log::error('Signature verification failed', [
                'signature' => substr($signature, 0, 20) . '...',
                'error' => $e->getMessage()
            ]);
            
            throw new SignatureVerificationException('Signature verification failed: ' . $e->getMessage());
        }
    }
    
    public function logSignatureVerification(Operation $operation, string $signature, array $response): void
    {
        SignatureVerification::create([
            'operation_id' => $operation->id,
            'signature' => $signature,
            'verification_status' => 'verified',
            'verification_response' => $response,
            'verified_at' => now()
        ]);
    }
}
```

### Signature Verification Middleware

```php
// Signature Verification Middleware
class SignatureVerificationMiddleware
{
    public function __construct(
        private SignatureVerificationService $signatureService
    ) {}

    public function handle(Request $request, Closure $next)
    {
        // Only apply to database API routes
        if (!$request->is('api/v1/database/*')) {
            return $next($request);
        }

        $signature = $request->header('X-APP-SIGNATURE');
        
        if (!$signature) {
            return response()->json([
                'success' => false,
                'error' => [
                    'code' => 'SIGNATURE_REQUIRED',
                    'message' => 'X-APP-SIGNATURE header is required'
                ]
            ], 401);
        }

        try {
            // Verify signature and extract tenant
            $tenant = $this->signatureService->verifyAndExtractTenant($signature);
            
            // Add tenant to request
            $request->merge(['tenant' => $tenant]);
            
        } catch (SignatureVerificationException $e) {
            return response()->json([
                'success' => false,
                'error' => [
                    'code' => 'SIGNATURE_VERIFICATION_FAILED',
                    'message' => $e->getMessage()
                ]
            ], 401);
        }

        return $next($request);
    }
}
```

---

## Soft Delete System

### Soft Delete Service

```php
// Soft Delete Service
class SoftDeleteService
{
    public function logSoftDelete(
        string $tenantId,
        string $tableName,
        string $recordId,
        $originalData,
        string $signature
    ): void {
        SoftDeleteLog::create([
            'tenant_id' => $tenantId,
            'table_name' => $tableName,
            'record_id' => $recordId,
            'original_data' => $originalData,
            'deleted_by' => $tenantId,
            'signature' => $signature
        ]);
    }
    
    public function recoverRecord(string $tenantId, string $tableName, string $recordId): bool
    {
        $log = SoftDeleteLog::where([
            'tenant_id' => $tenantId,
            'table_name' => $tableName,
            'record_id' => $recordId
        ])->first();
        
        if (!$log) {
            return false;
        }
        
        // Restore the record
        DB::connection('ui_api')
            ->table($tableName)
            ->where('id', $recordId)
            ->update([
                'deleted_at' => null,
                'deleted_by' => null
            ]);
            
        // Remove from soft delete log
        $log->delete();
        
        return true;
    }
    
    public function permanentlyDeleteRecord(string $tenantId, string $tableName, string $recordId, string $signature): bool
    {
        $log = SoftDeleteLog::where([
            'tenant_id' => $tenantId,
            'table_name' => $tableName,
            'record_id' => $recordId
        ])->first();
        
        if (!$log) {
            return false;
        }
        
        // Permanently delete the record
        DB::connection('ui_api')
            ->table($tableName)
            ->where('id', $recordId)
            ->delete();
            
        // Remove from soft delete log
        $log->delete();
        
        return true;
    }
    
    public function getSoftDeletedRecords(string $tenantId, string $tableName = null): Collection
    {
        $query = SoftDeleteLog::where('tenant_id', $tenantId);
        
        if ($tableName) {
            $query->where('table_name', $tableName);
        }
        
        return $query->get();
    }
}
```

---

## New API Controllers & Services

### Metadata Controller

```php
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use App\Http\Resources\FilterResource;
use App\Http\Resources\AggregationResource;
use App\Http\Resources\ColumnResource;
use App\Services\MetadataService;
use Illuminate\Http\Request;

class MetadataController extends Controller
{
    public function __construct(
        private MetadataService $metadataService
    ) {}

    public function getFilters(Request $request)
    {
        $filters = $this->metadataService->getAllFilterOperators();
        
        return response()->json([
            'status' => 'success',
            'message' => __('messages.filters_retrieved_successfully'),
            'data' => FilterResource::collection($filters)
        ], 200);
    }

    public function getAggregations(Request $request)
    {
        $aggregations = $this->metadataService->getAllAggregationFunctions();
        
        return response()->json([
            'status' => 'success',
            'message' => __('messages.aggregations_retrieved_successfully'),
            'data' => AggregationResource::collection($aggregations)
        ], 200);
    }

    public function getAllColumns(Request $request)
    {
        $tenantId = $request->get('tenant_id');
        $columns = $this->metadataService->getAllTenantColumns($tenantId);
        
        return response()->json([
            'status' => 'success',
            'message' => __('messages.columns_retrieved_successfully'),
            'data' => ColumnResource::collection($columns)
        ], 200);
    }
}
```

### Raw Query Controller

```php
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use App\Http\Requests\RawQueryRequest;
use App\Services\RawQueryService;
use Illuminate\Http\Request;

class RawQueryController extends Controller
{
    public function __construct(
        private RawQueryService $rawQueryService
    ) {}

    public function execute(RawQueryRequest $request)
    {
        $tenantId = $request->get('tenant_id');
        $query = $request->input('query');
        
        try {
            $result = $this->rawQueryService->executeSafeQuery($query, $tenantId);
            
            return response()->json([
                'status' => 'success',
                'message' => __('messages.query_executed_successfully'),
                'data' => $result
            ], 200);
            
        } catch (\Exception $e) {
            return response()->json([
                'status' => 'error',
                'message' => __('messages.query_execution_failed'),
                'error' => [
                    'code' => 'QUERY_EXECUTION_FAILED',
                    'details' => $e->getMessage()
                ]
            ], 400);
        }
    }
}
```

### Metadata Service

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\DB;

class MetadataService
{
    public function getAllFilterOperators(): array
    {
        return [
            [
                'name' => 'equals',
                'label' => 'Equals',
                'operator' => '=',
                'description' => 'Exact match'
            ],
            [
                'name' => 'not_equals',
                'label' => 'Not Equals',
                'operator' => '!=',
                'description' => 'Not equal to'
            ],
            [
                'name' => 'greater_than',
                'label' => 'Greater Than',
                'operator' => '>',
                'description' => 'Greater than value'
            ],
            [
                'name' => 'greater_than_equal',
                'label' => 'Greater Than or Equal',
                'operator' => '>=',
                'description' => 'Greater than or equal to value'
            ],
            [
                'name' => 'less_than',
                'label' => 'Less Than',
                'operator' => '<',
                'description' => 'Less than value'
            ],
            [
                'name' => 'less_than_equal',
                'label' => 'Less Than or Equal',
                'operator' => '<=',
                'description' => 'Less than or equal to value'
            ],
            [
                'name' => 'like',
                'label' => 'Contains',
                'operator' => 'LIKE',
                'description' => 'Contains text (use % wildcards)'
            ],
            [
                'name' => 'not_like',
                'label' => 'Does Not Contain',
                'operator' => 'NOT LIKE',
                'description' => 'Does not contain text'
            ],
            [
                'name' => 'in',
                'label' => 'In List',
                'operator' => 'IN',
                'description' => 'Value is in list'
            ],
            [
                'name' => 'not_in',
                'label' => 'Not In List',
                'operator' => 'NOT IN',
                'description' => 'Value is not in list'
            ],
            [
                'name' => 'between',
                'label' => 'Between',
                'operator' => 'BETWEEN',
                'description' => 'Value is between two values'
            ],
            [
                'name' => 'not_between',
                'label' => 'Not Between',
                'operator' => 'NOT BETWEEN',
                'description' => 'Value is not between two values'
            ],
            [
                'name' => 'is_null',
                'label' => 'Is Null',
                'operator' => 'IS NULL',
                'description' => 'Value is null'
            ],
            [
                'name' => 'is_not_null',
                'label' => 'Is Not Null',
                'operator' => 'IS NOT NULL',
                'description' => 'Value is not null'
            ],
            [
                'name' => 'starts_with',
                'label' => 'Starts With',
                'operator' => 'LIKE',
                'description' => 'Starts with text'
            ],
            [
                'name' => 'ends_with',
                'label' => 'Ends With',
                'operator' => 'LIKE',
                'description' => 'Ends with text'
            ]
        ];
    }

    public function getAllAggregationFunctions(): array
    {
        return [
            [
                'name' => 'count',
                'label' => 'Count',
                'description' => 'Count number of records',
                'syntax' => 'COUNT(*)',
                'supports_group_by' => true
            ],
            [
                'name' => 'count_distinct',
                'label' => 'Count Distinct',
                'description' => 'Count distinct values',
                'syntax' => 'COUNT(DISTINCT column)',
                'supports_group_by' => true
            ],
            [
                'name' => 'sum',
                'label' => 'Sum',
                'description' => 'Sum of numeric values',
                'syntax' => 'SUM(column)',
                'supports_group_by' => true,
                'numeric_only' => true
            ],
            [
                'name' => 'avg',
                'label' => 'Average',
                'description' => 'Average of numeric values',
                'syntax' => 'AVG(column)',
                'supports_group_by' => true,
                'numeric_only' => true
            ],
            [
                'name' => 'min',
                'label' => 'Minimum',
                'description' => 'Minimum value',
                'syntax' => 'MIN(column)',
                'supports_group_by' => true
            ],
            [
                'name' => 'max',
                'label' => 'Maximum',
                'description' => 'Maximum value',
                'syntax' => 'MAX(column)',
                'supports_group_by' => true
            ],
            [
                'name' => 'group_concat',
                'label' => 'Group Concatenate',
                'description' => 'Concatenate values in group',
                'syntax' => 'GROUP_CONCAT(column)',
                'supports_group_by' => true
            ]
        ];
    }

    public function getAllTenantColumns(string $tenantId): array
    {
        $columns = DB::connection('ui_api')->select("
            SELECT 
                c.TABLE_SCHEMA,
                c.TABLE_NAME,
                c.COLUMN_NAME,
                c.ORDINAL_POSITION,
                c.COLUMN_DEFAULT,
                c.IS_NULLABLE,
                c.DATA_TYPE,
                c.CHARACTER_MAXIMUM_LENGTH,
                c.NUMERIC_PRECISION,
                c.NUMERIC_SCALE,
                c.DATETIME_PRECISION,
                c.CHARACTER_SET_NAME,
                c.COLLATION_NAME,
                c.COLUMN_TYPE,
                c.COLUMN_KEY,
                c.EXTRA,
                c.PRIVILEGES,
                c.COLUMN_COMMENT,
                c.GENERATION_EXPRESSION,
                c.SRS_ID
            FROM information_schema.COLUMNS c
            INNER JOIN information_schema.TABLES t ON c.TABLE_SCHEMA = t.TABLE_SCHEMA AND c.TABLE_NAME = t.TABLE_NAME
            WHERE c.TABLE_SCHEMA NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
            AND t.TABLE_TYPE = 'BASE TABLE'
            ORDER BY c.TABLE_SCHEMA, c.TABLE_NAME, c.ORDINAL_POSITION
        ");

        return $columns;
    }
}
```

### Raw Query Service

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class RawQueryService
{
    private const PROHIBITED_PATTERNS = [
        '/\bDROP\b/i',
        '/\bCREATE\b/i',
        '/\bALTER\b/i',
        '/\bINSERT\b/i',
        '/\bUPDATE\b/i',
        '/\bDELETE\b/i',
        '/\bTRUNCATE\b/i',
        '/\bGRANT\b/i',
        '/\bREVOKE\b/i',
        '/\bKILL\b/i',
        '/\bSHUTDOWN\b/i',
        '/\bFLUSH\b/i',
        '/\bRESET\b/i',
        '/\b1\s*=\s*1\b/i', // Prevent 1=1 comparisons
        '/\b\d+\s*=\s*\d+\b/i', // Prevent numeric comparisons
        '/\bUNION\b/i',
        '/\bEXEC\b/i',
        '/\bEXECUTE\b/i',
        '/\bSP_\w+/i', // Prevent stored procedure calls
        '/\bxp_\w+/i', // Prevent extended procedure calls
    ];

    public function executeSafeQuery(string $query, string $tenantId): array
    {
        // 1. Validate query is SELECT only
        $this->validateSelectOnly($query);
        
        // 2. Check for prohibited patterns
        $this->validateProhibitedPatterns($query);
        
        // 3. Validate column-value comparisons only
        $this->validateColumnValueComparisons($query);
        
        // 4. Apply query limits
        $limitedQuery = $this->applyQueryLimits($query);
        
        // 5. Execute query
        $results = DB::connection('ui_api')->select($limitedQuery);
        
        // 6. Log query execution
        Log::info('Raw query executed', [
            'tenant_id' => $tenantId,
            'query' => $limitedQuery,
            'result_count' => count($results)
        ]);
        
        return [
            'results' => $results,
            'count' => count($results),
            'query_executed' => $limitedQuery,
            'limited' => $this->wasQueryLimited($query, $limitedQuery)
        ];
    }

    private function validateSelectOnly(string $query): void
    {
        $queryUpper = strtoupper(trim($query));
        
        if (!str_starts_with($queryUpper, 'SELECT')) {
            throw new \InvalidArgumentException('Only SELECT queries are allowed');
        }
        
        // Check for multiple statements
        if (strpos($queryUpper, ';') !== false && substr_count($queryUpper, ';') > 1) {
            throw new \InvalidArgumentException('Multiple statements not allowed');
        }
    }

    private function validateProhibitedPatterns(string $query): void
    {
        foreach (self::PROHIBITED_PATTERNS as $pattern) {
            if (preg_match($pattern, $query)) {
                throw new \InvalidArgumentException('Query contains prohibited patterns');
            }
        }
    }

    private function validateColumnValueComparisons(string $query): void
    {
        // Extract WHERE clauses
        preg_match_all('/WHERE\s+(.+?)(?:\s+GROUP\s+BY|\s+ORDER\s+BY|\s+HAVING|\s+LIMIT|$)/i', $query, $matches);
        
        if (!empty($matches[1])) {
            foreach ($matches[1] as $whereClause) {
                // Check for value-to-value comparisons
                if (preg_match('/\b\d+\s*[=<>!]+\s*\d+\b/', $whereClause)) {
                    throw new \InvalidArgumentException('Value-to-value comparisons not allowed');
                }
                
                // Check for suspicious patterns
                if (preg_match('/\b\w+\s*=\s*\w+\s*AND\s*\w+\s*=\s*\w+\b/i', $whereClause)) {
                    throw new \InvalidArgumentException('Suspicious comparison pattern detected');
                }
            }
        }
    }

    private function applyQueryLimits(string $query): string
    {
        $queryUpper = strtoupper($query);
        
        // Check if LIMIT already exists
        if (strpos($queryUpper, 'LIMIT') !== false) {
            // Extract existing limit
            preg_match('/LIMIT\s+(\d+)/i', $query, $matches);
            $existingLimit = isset($matches[1]) ? (int)$matches[1] : 1000;
            
            // Apply maximum limit
            $maxLimit = 1000; // Default limit for raw queries
            $newLimit = min($existingLimit, $maxLimit);
            
            return preg_replace('/LIMIT\s+\d+/i', "LIMIT {$newLimit}", $query);
        }
        
        // Add LIMIT if not present
        return $query . " LIMIT 1000";
    }

    private function wasQueryLimited(string $originalQuery, string $limitedQuery): bool
    {
        return $originalQuery !== $limitedQuery;
    }
}
```

### Resource Classes

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Resources\Json\JsonResource;

class FilterResource extends JsonResource
{
    public function toArray($request)
    {
        return [
            'name' => $this->resource['name'],
            'label' => $this->resource['label'],
            'operator' => $this->resource['operator'],
            'description' => $this->resource['description']
        ];
    }
}

class AggregationResource extends JsonResource
{
    public function toArray($request)
    {
        return [
            'name' => $this->resource['name'],
            'label' => $this->resource['label'],
            'description' => $this->resource['description'],
            'syntax' => $this->resource['syntax'],
            'supports_group_by' => $this->resource['supports_group_by'],
            'numeric_only' => $this->resource['numeric_only'] ?? false
        ];
    }
}

class ColumnResource extends JsonResource
{
    public function toArray($request)
    {
        return [
            'schema' => $this->resource->TABLE_SCHEMA,
            'table' => $this->resource->TABLE_NAME,
            'column' => $this->resource->COLUMN_NAME,
            'position' => $this->resource->ORDINAL_POSITION,
            'default' => $this->resource->COLUMN_DEFAULT,
            'nullable' => $this->resource->IS_NULLABLE === 'YES',
            'data_type' => $this->resource->DATA_TYPE,
            'max_length' => $this->resource->CHARACTER_MAXIMUM_LENGTH,
            'precision' => $this->resource->NUMERIC_PRECISION,
            'scale' => $this->resource->NUMERIC_SCALE,
            'datetime_precision' => $this->resource->DATETIME_PRECISION,
            'charset' => $this->resource->CHARACTER_SET_NAME,
            'collation' => $this->resource->COLLATION_NAME,
            'column_type' => $this->resource->COLUMN_TYPE,
            'key' => $this->resource->COLUMN_KEY,
            'extra' => $this->resource->EXTRA,
            'privileges' => $this->resource->PRIVILEGES,
            'comment' => $this->resource->COLUMN_COMMENT,
            'generation_expression' => $this->resource->GENERATION_EXPRESSION,
            'srs_id' => $this->resource->SRS_ID
        ];
    }
}
```

### Raw Query Request Validation

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class RawQueryRequest extends FormRequest
{
    public function authorize()
    {
        return true;
    }

    public function rules()
    {
        return [
            'query' => [
                'required',
                'string',
                'max:10000', // Reasonable limit for query length
                'regex:/^SELECT\s+/i' // Must start with SELECT
            ]
        ];
    }

    public function messages()
    {
        return [
            'query.required' => __('validation.query_required'),
            'query.string' => __('validation.query_string'),
            'query.max' => __('validation.query_max_length'),
            'query.regex' => __('validation.query_must_start_with_select')
        ];
    }
}
```

### Multilingual Support

```php
<?php

// resources/lang/en/messages.php
return [
    'filters_retrieved_successfully' => 'Filter operators retrieved successfully',
    'aggregations_retrieved_successfully' => 'Aggregation functions retrieved successfully',
    'columns_retrieved_successfully' => 'Table columns retrieved successfully',
    'query_executed_successfully' => 'Query executed successfully',
    'query_execution_failed' => 'Query execution failed',
    'operation_created_successfully' => 'Operation created successfully',
    'operation_updated_successfully' => 'Operation updated successfully',
    'operation_deleted_successfully' => 'Operation deleted successfully',
    'batch_approved_successfully' => 'Batch approved successfully',
    'batch_rejected_successfully' => 'Batch rejected successfully',
];

// resources/lang/en/validation.php
return [
    'query_required' => 'Query is required',
    'query_string' => 'Query must be a string',
    'query_max_length' => 'Query exceeds maximum length',
    'query_must_start_with_select' => 'Query must start with SELECT',
];
```

### 1. Operation Naming Service

#### OperationNamingService.php
```php
<?php

namespace App\Services;

use App\Models\OperationGroup;
use App\Models\OperationCase;

class OperationNamingService
{
    public function generateName(array $requestData, $tenant): string
    {
        $operationType = $requestData['type'];
        $tableName = $requestData['table_name'] ?? 'unknown';
        $caseId = $requestData['case_id'];
        
        $case = OperationCase::findOrFail($caseId);
        
        if ($case->execution_mode === 'batch') {
            return $this->generateBatchName($operationType, $tableName, $tenant);
        }
        
        return $this->generateInstantName($operationType, $tableName, $requestData);
    }
    
    private function generateBatchName(string $operationType, string $tableName, $tenant): string
    {
        // Get next batch number for tenant
        $batchNumber = $this->getNextBatchNumber($tenant->id);
        
        switch (strtoupper($operationType)) {
            case 'CREATE_TABLE':
                return "BATCH{$batchNumber}_CREATE_{$tableName}_TABLE";
            case 'ALTER_TABLE':
                return "BATCH{$batchNumber}_ALTER_{$tableName}_TABLE";
            case 'DROP_TABLE':
                return "BATCH{$batchNumber}_DROP_{$tableName}_TABLE";
            case 'CREATE_INDEX':
                return "BATCH{$batchNumber}_CREATE_{$tableName}_INDEX";
            case 'DROP_INDEX':
                return "BATCH{$batchNumber}_DROP_{$tableName}_INDEX";
            case 'ADD_FOREIGN_KEY':
                return "BATCH{$batchNumber}_ADD_{$tableName}_FK";
            case 'DROP_FOREIGN_KEY':
                return "BATCH{$batchNumber}_DROP_{$tableName}_FK";
            default:
                return "BATCH{$batchNumber}_{$operationType}_{$tableName}";
        }
    }
    
    private function generateInstantName(string $operationType, string $tableName, array $requestData): string
    {
        switch (strtoupper($operationType)) {
            case 'SELECT':
                $hasFilters = $this->hasFilters($requestData);
                return "INSTANT_SELECT_{$tableName}_" . ($hasFilters ? 'WITH' : 'WITHOUT') . "_FILTERS";
            case 'INSERT':
                return "INSTANT_INSERT_{$tableName}_RECORD";
            case 'UPDATE':
                return "INSTANT_UPDATE_{$tableName}_RECORD";
            case 'DELETE':
                return "INSTANT_DELETE_{$tableName}_RECORD";
            default:
                return "INSTANT_{$operationType}_{$tableName}";
        }
    }
    
    private function getNextBatchNumber(string $tenantId): int
    {
        $lastBatch = OperationGroup::where('tenant_id', $tenantId)
            ->where('name', 'like', 'BATCH%')
            ->orderBy('created_at', 'desc')
            ->first();
            
        if (!$lastBatch) {
            return 1;
        }
        
        preg_match('/BATCH(\d+)_/', $lastBatch->name, $matches);
        return (int)($matches[1] ?? 0) + 1;
    }
    
    private function hasFilters(array $requestData): bool
    {
        return !empty($requestData['filters']) || !empty($requestData['where']);
    }
}
```

### 2. Tenant Security Service

#### TenantSecurityService.php
```php
<?php

namespace App\Services;

use App\Models\Tenant;
use App\Models\TenantSecurityLog;

class TenantSecurityService
{
    private const MAX_DENIED_QUERIES = 3;
    
    public function validateTenantAccess(Tenant $tenant): void
    {
        if ($tenant->is_blocked) {
            throw new TenantBlockedException('Tenant is blocked due to security violations');
        }
        
        // Check recent security violations
        $recentViolations = TenantSecurityLog::where('tenant_id', $tenant->id)
            ->where('created_at', '>=', now()->subHours(24))
            ->count();
            
        if ($recentViolations >= self::MAX_DENIED_QUERIES) {
            $this->blockTenant($tenant, 'Exceeded maximum denied queries in 24 hours');
            throw new TenantBlockedException('Tenant blocked due to excessive security violations');
        }
    }
    
    public function logDeniedQuery(Tenant $tenant, string $operationType, string $query, string $reason, Request $request): void
    {
        TenantSecurityLog::create([
            'tenant_id' => $tenant->id,
            'operation_type' => $operationType,
            'denied_query' => $query,
            'reason' => $reason,
            'ip_address' => $request->ip(),
            'user_agent' => $request->userAgent()
        ]);
        
        // Check if tenant should be blocked
        $totalViolations = TenantSecurityLog::where('tenant_id', $tenant->id)->count();
        
        if ($totalViolations >= self::MAX_DENIED_QUERIES) {
            $this->blockTenant($tenant, 'Exceeded maximum denied queries');
        }
    }
    
    private function blockTenant(Tenant $tenant, string $reason): void
    {
        $tenant->update([
            'is_blocked' => true,
            'blocked_at' => now(),
            'block_reason' => $reason
        ]);
        
        // Log the blocking event
        Log::warning('Tenant blocked', [
            'tenant_id' => $tenant->id,
            'reason' => $reason,
            'total_violations' => TenantSecurityLog::where('tenant_id', $tenant->id)->count()
        ]);
        
        // Notify admins
        $this->notifyAdminsTenantBlocked($tenant, $reason);
    }
    
    private function notifyAdminsTenantBlocked(Tenant $tenant, string $reason): void
    {
        // Implementation depends on your notification system
        // Could be email, Slack, or other notification channels
    }
}
```

### 3. Query Limits Service

#### QueryLimitsService.php
```php
<?php

namespace App\Services;

use App\Models\QueryLimit;
use App\Models\OperationCase;

class QueryLimitsService
{
    public function getLimitsForOperation($operation): QueryLimits
    {
        $limits = QueryLimit::where('case_id', $operation->case_id)
            ->where('operation_type', $operation->type)
            ->first();
            
        if (!$limits) {
            // Return default limits
            return new QueryLimits([
                'max_columns_threshold' => 3,
                'max_records_small_table' => 1000,
                'max_records_large_table' => 100,
                'soft_delete_enabled' => true
            ]);
        }
        
        return new QueryLimits([
            'max_columns_threshold' => $limits->max_columns_threshold,
            'max_records_small_table' => $limits->max_records_small_table,
            'max_records_large_table' => $limits->max_records_large_table,
            'soft_delete_enabled' => $limits->soft_delete_enabled
        ]);
    }
    
    public function calculateColumnCount(string $tableName): int
    {
        $columns = DB::connection('ui_api')
            ->select("SELECT COUNT(*) as count FROM information_schema.columns WHERE table_name = ?", [$tableName]);
            
        return $columns[0]->count;
    }
    
    public function getMaxRecordsForTable(string $tableName): int
    {
        $columnCount = $this->calculateColumnCount($tableName);
        
        // Global limits as per requirements
        if ($columnCount <= 3) {
            return 1000; // Small table
        }
        
        return 100; // Large table
    }
}

class QueryLimits
{
    public function __construct(private array $limits) {}
    
    public function maxColumnsThreshold(): int
    {
        return $this->limits['max_columns_threshold'];
    }
    
    public function maxRecordsSmallTable(): int
    {
        return $this->limits['max_records_small_table'];
    }
    
    public function maxRecordsLargeTable(): int
    {
        return $this->limits['max_records_large_table'];
    }
    
    public function softDeleteEnabled(): bool
    {
        return $this->limits['soft_delete_enabled'];
    }
    
    public function hasFilters(string $sql): bool
    {
        return stripos($sql, 'WHERE') !== false || stripos($sql, 'HAVING') !== false;
    }
    
    public function getMaxRecordsWithFilters(): int
    {
        return min($this->maxRecordsSmallTable(), $this->maxRecordsLargeTable());
    }
    
    public function getMaxRecordsWithoutFilters(): int
    {
        return $this->maxRecordsSmallTable();
    }
}
```

### 4. SOLID-Compliant Operation Handler Factory

#### OperationHandlerFactory.php
```php
<?php

namespace App\Services;

// Interface Segregation Principle
interface OperationHandlerInterface
{
    public function canHandle(string $operationType): bool;
    public function execute(Operation $operation): OperationResult;
}

interface BatchProcessorInterface
{
    public function processBatch(OperationGroup $group): void;
    public function requiresApproval(): bool;
}

interface InstantProcessorInterface
{
    public function processInstant(Operation $operation): OperationResult;
    public function getQueryLimits(Operation $operation): QueryLimits;
}

// Single Responsibility Principle
class CreateTableHandler implements OperationHandlerInterface, BatchProcessorInterface
{
    public function __construct(
        private SqlGeneratorService $sqlGenerator,
        private ValidationService $validator
    ) {}

    public function canHandle(string $operationType): bool
    {
        return $operationType === 'create_table';
    }
    
    public function execute(Operation $operation): OperationResult
    {
        // Generate SQL
        $sql = $this->sqlGenerator->generateCreateTableSql($operation->payload);
        
        // Validate SQL
        $this->validator->validateTableStructure($operation->payload);
        
        return new OperationResult([
            'success' => true,
            'sql' => $sql,
            'operation_id' => $operation->id
        ]);
    }
    
    public function processBatch(OperationGroup $group): void
    {
        // Batch processing logic for table creation
    }
    
    public function requiresApproval(): bool
    {
        return true;
    }
}

class DataQueryHandler implements OperationHandlerInterface, InstantProcessorInterface
{
    public function __construct(
        private QueryLimitsService $limitsService,
        private SoftDeleteService $softDeleteService
    ) {}

    public function canHandle(string $operationType): bool
    {
        return in_array($operationType, ['select', 'insert', 'update', 'delete']);
    }
    
    public function execute(Operation $operation): OperationResult
    {
        return $this->processInstant($operation);
    }
    
    public function processInstant(Operation $operation): OperationResult
    {
        $limits = $this->getQueryLimits($operation);
        
        switch ($operation->type) {
            case 'select':
                return $this->processSelect($operation, $limits);
            case 'insert':
                return $this->processInsert($operation);
            case 'update':
                return $this->processUpdate($operation);
            case 'delete':
                return $this->processSoftDelete($operation);
        }
    }
    
    public function getQueryLimits(Operation $operation): QueryLimits
    {
        return $this->limitsService->getLimitsForOperation($operation);
    }
    
    private function processSelect(Operation $operation, QueryLimits $limits): OperationResult
    {
        $sql = $operation->sql_preview;
        
        // Enforce limits
        if ($limits->hasFilters($sql)) {
            $sql .= " LIMIT {$limits->getMaxRecordsWithFilters()}";
        } else {
            $sql .= " LIMIT {$limits->getMaxRecordsWithoutFilters()}";
        }
        
        $results = DB::connection('ui_api')->select($sql);
        
        return new OperationResult([
            'success' => true,
            'data' => $results,
            'count' => count($results),
            'limited' => count($results) >= $limits->getMaxRecordsWithoutFilters()
        ]);
    }
    
    private function processSoftDelete(Operation $operation): OperationResult
    {
        // Implementation as shown in previous section
        return $this->softDeleteService->processSoftDelete($operation);
    }
}

// Open/Closed Principle - Factory Pattern
class OperationHandlerFactory
{
    private array $handlers = [];
    
    public function registerHandler(OperationHandlerInterface $handler): void
    {
        $this->handlers[] = $handler;
    }
    
    public function getHandler(string $operationType): OperationHandlerInterface
    {
        foreach ($this->handlers as $handler) {
            if ($handler->canHandle($operationType)) {
                return $handler;
            }
        }
        throw new UnsupportedOperationException("No handler for operation type: {$operationType}");
    }
    
    public function registerDefaultHandlers(): void
    {
        $this->registerHandler(new CreateTableHandler(
            app(SqlGeneratorService::class),
            app(ValidationService::class)
        ));
        
        $this->registerHandler(new DataQueryHandler(
            app(QueryLimitsService::class),
            app(SoftDeleteService::class)
        ));
        
        // Register other handlers...
    }
}
```

### 5. Enhanced Security Middleware with Tenant Support

#### TenantSecurityMiddleware.php
```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use App\Services\TenantSecurityService;

class TenantSecurityMiddleware
{
    private const DENY_LIST = [
        'DROP DATABASE', 'DROP TABLE', 'DROP USER', 'DROP VIEW', 
        'DROP TRIGGER', 'DROP EVENT', 'DROP FUNCTION', 'DROP PROCEDURE',
        'GRANT', 'REVOKE', 'CREATE USER', 'ALTER DATABASE', 
        'KILL', 'SHUTDOWN', 'FLUSH', 'RESET'
    ];

    private const ALLOW_LIST = [
        'CREATE TABLE', 'ALTER TABLE', 'CREATE VIEW', 'ALTER VIEW',
        'CREATE TRIGGER', 'ALTER TRIGGER', 'CREATE PROCEDURE', 'ALTER PROCEDURE',
        'CREATE FUNCTION', 'ALTER FUNCTION', 'CREATE EVENT', 'ALTER EVENT',
        'CREATE INDEX', 'DROP INDEX', 'INSERT', 'UPDATE', 'DELETE', 'SELECT'
    ];

    public function __construct(
        private TenantSecurityService $securityService
    ) {}

    public function handle(Request $request, Closure $next)
    {
        // Only apply to database API routes
        if (!$request->is('api/v1/database/*')) {
            return $next($request);
        }

        // Skip for preview-only endpoints
        if ($request->is('api/v1/database/preview-sql')) {
            return $next($request);
        }

        // Get tenant from request (set by SignatureVerificationMiddleware)
        $tenant = $request->get('tenant');
        
        if (!$tenant) {
            return response()->json([
                'success' => false,
                'error' => [
                    'code' => 'TENANT_REQUIRED',
                    'message' => 'Tenant information is required'
                ]
            ], 401);
        }

        // Extract SQL from request (generated by SqlGeneratorService)
        $sql = $request->input('generated_sql') ?? $request->input('sql');
        
        if ($sql) {
            $this->validateSql($sql, $request, $tenant);
        }

        return $next($request);
    }

    private function validateSql(string $sql, Request $request, $tenant): void
    {
        $sqlUpper = strtoupper(trim($sql));
        
        // Check deny list
        foreach (self::DENY_LIST as $denied) {
            if (strpos($sqlUpper, $denied) !== false) {
                // Log denied query
                $this->securityService->logDeniedQuery(
                    $tenant,
                    $request->input('type', 'unknown'),
                    $sql,
                    "Blocked dangerous operation: {$denied}",
                    $request
                );
                
                Log::warning('Blocked dangerous SQL', [
                    'sql' => $sql,
                    'tenant_id' => $tenant->id,
                    'ip' => $request->ip(),
                    'user_agent' => $request->userAgent()
                ]);
                
                abort(403, 'OPERATION_NOT_PERMITTED: ' . $denied . ' operations are not allowed');
            }
        }

        // Validate against allow list for DDL operations
        if ($this->isDdlOperation($sqlUpper)) {
            $allowed = false;
            foreach (self::ALLOW_LIST as $allowedOp) {
                if (strpos($sqlUpper, $allowedOp) !== false) {
                    $allowed = true;
                    break;
                }
            }
            
            if (!$allowed) {
                // Log denied query
                $this->securityService->logDeniedQuery(
                    $tenant,
                    $request->input('type', 'unknown'),
                    $sql,
                    'DDL operation not in allow list',
                    $request
                );
                
                Log::warning('Blocked non-whitelisted DDL', [
                    'sql' => $sql,
                    'tenant_id' => $tenant->id
                ]);
                
                abort(403, 'OPERATION_NOT_PERMITTED: DDL operation not in allow list');
            }
        }
    }

    private function isDdlOperation(string $sql): bool
    {
        $ddlKeywords = ['CREATE', 'ALTER', 'DROP', 'TRUNCATE'];
        foreach ($ddlKeywords as $keyword) {
            if (strpos($sql, $keyword) === 0) {
                return true;
            }
        }
        return false;
    }
}
```

### 2. Job-Based DDL Operations

#### Operation Model
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Operation extends Model
{
    use HasFactory;

    protected $fillable = [
        'id',
        'user_id',
        'type',
        'schema_name',
        'table_name',
        'payload',
        'sql_preview',
        'status',
        'result',
        'error_message',
        'started_at',
        'completed_at'
    ];

    protected $casts = [
        'payload' => 'array',
        'result' => 'array',
        'started_at' => 'datetime',
        'completed_at' => 'datetime'
    ];

    const STATUS_QUEUED = 'queued';
    const STATUS_RUNNING = 'running';
    const STATUS_SUCCESS = 'success';
    const STATUS_FAILED = 'failed';
    const STATUS_CANCELLED = 'cancelled';

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}
```

#### ProcessDdlOperation Job
```php
<?php

namespace App\Jobs;

use App\Models\Operation;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class ProcessDdlOperation implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 300; // 5 minutes
    public $tries = 3;

    protected $operation;

    public function __construct(Operation $operation)
    {
        $this->operation = $operation;
    }

    public function handle()
    {
        $this->operation->update([
            'status' => Operation::STATUS_RUNNING,
            'started_at' => now()
        ]);

        try {
            DB::connection('ui_api')->beginTransaction();
            
            // Execute the SQL
            $result = DB::connection('ui_api')->statement($this->operation->sql_preview);
            
            DB::connection('ui_api')->commit();
            
            $this->operation->update([
                'status' => Operation::STATUS_SUCCESS,
                'result' => ['executed' => true, 'affected_rows' => DB::connection('ui_api')->getPdo()->lastInsertId()],
                'completed_at' => now()
            ]);

            Log::info('DDL operation completed successfully', [
                'operation_id' => $this->operation->id,
                'user_id' => $this->operation->user_id,
                'type' => $this->operation->type
            ]);

        } catch (\Exception $e) {
            DB::connection('ui_api')->rollBack();
            
            $this->operation->update([
                'status' => Operation::STATUS_FAILED,
                'error_message' => $e->getMessage(),
                'completed_at' => now()
            ]);

            Log::error('DDL operation failed', [
                'operation_id' => $this->operation->id,
                'user_id' => $this->operation->user_id,
                'error' => $e->getMessage(),
                'sql' => $this->operation->sql_preview
            ]);

            throw $e;
        }
    }

    public function failed(\Throwable $exception)
    {
        $this->operation->update([
            'status' => Operation::STATUS_FAILED,
            'error_message' => $exception->getMessage(),
            'completed_at' => now()
        ]);
    }
}
```

### 3. SqlGeneratorService Implementation

#### SqlGeneratorService.php
```php
<?php

namespace App\Services;

use App\Models\Table;
use App\Models\Column;
use App\Models\Index;
use App\Models\ForeignKey;
use App\Models\CheckConstraint;
use App\Models\Partitioning;

class SqlGeneratorService
{
    public function generateCreateTableSql(Table $table): string
    {
        $sql = "CREATE TABLE `{$table->name}` (\n";
        
        // Generate columns
        $columnSqls = [];
        foreach ($table->columns as $column) {
            $columnSqls[] = $this->generateColumnDefinition($column);
        }
        
        // Generate primary key
        $primaryKeyColumns = $table->columns->where('primary_key', true)->pluck('name');
        if ($primaryKeyColumns->isNotEmpty()) {
            $columnSqls[] = "PRIMARY KEY (`" . $primaryKeyColumns->implode('`, `') . "`)";
        }
        
        // Generate indexes
        foreach ($table->indexes as $index) {
            $columnSqls[] = $this->generateIndexDefinition($index);
        }
        
        // Generate foreign keys
        foreach ($table->foreignKeys as $foreignKey) {
            $columnSqls[] = $this->generateForeignKeyDefinition($foreignKey);
        }
        
        // Generate check constraints
        foreach ($table->checks as $check) {
            $columnSqls[] = $this->generateCheckConstraintDefinition($check);
        }
        
        $sql .= "  " . implode(",\n  ", $columnSqls) . "\n";
        
        // Add table options
        $sql .= ") " . $this->generateTableOptions($table->options);
        
        // Add partitioning
        if ($table->partitions) {
            $sql .= " " . $this->generatePartitioningDefinition($table->partitions);
        }
        
        return $sql;
    }

    public function generateAlterTableSql(string $tableName, array $changes): string
    {
        $sqlParts = [];
        
        foreach ($changes as $change) {
            switch ($change['type']) {
                case 'add_column':
                    $sqlParts[] = "ADD COLUMN " . $this->generateColumnDefinition($change['column']);
                    break;
                    
                case 'modify_column':
                    $sqlParts[] = "MODIFY COLUMN " . $this->generateColumnDefinition($change['column']);
                    break;
                    
                case 'drop_column':
                    $sqlParts[] = "DROP COLUMN `{$change['column_name']}`";
                    break;
                    
                case 'add_index':
                    $sqlParts[] = "ADD " . $this->generateIndexDefinition($change['index']);
                    break;
                    
                case 'drop_index':
                    $sqlParts[] = "DROP INDEX `{$change['index_name']}`";
                    break;
                    
                case 'add_foreign_key':
                    $sqlParts[] = "ADD " . $this->generateForeignKeyDefinition($change['foreign_key']);
                    break;
                    
                case 'drop_foreign_key':
                    $sqlParts[] = "DROP FOREIGN KEY `{$change['constraint_name']}`";
                    break;
            }
        }
        
        return "ALTER TABLE `{$tableName}` " . implode(", ", $sqlParts);
    }

    private function generateColumnDefinition(Column $column): string
    {
        $sql = "`{$column->name}` ";
        
        // Data type with length/precision
        $sql .= $this->generateDataType($column);
        
        // Attributes
        if (!$column->nullable) {
            $sql .= " NOT NULL";
        }
        
        if ($column->auto_increment) {
            $sql .= " AUTO_INCREMENT";
        }
        
        if ($column->default !== null) {
            $sql .= " DEFAULT " . $this->generateDefaultValue($column->default);
        }
        
        if ($column->generated) {
            $sql .= " GENERATED ALWAYS AS ({$column->generated['expression']}) " . strtoupper($column->generated['type']);
        }
        
        if ($column->comment) {
            $sql .= " COMMENT '" . addslashes($column->comment) . "'";
        }
        
        return $sql;
    }

    private function generateDataType(Column $column): string
    {
        $type = strtoupper($column->data_type);
        
        switch ($type) {
            case 'VARCHAR':
            case 'CHAR':
            case 'BINARY':
            case 'VARBINARY':
                return "{$type}({$column->length})";
                
            case 'DECIMAL':
            case 'NUMERIC':
                return "{$type}({$column->precision},{$column->scale})";
                
            case 'FLOAT':
            case 'DOUBLE':
                if ($column->precision) {
                    return "{$type}({$column->precision},{$column->scale})";
                }
                return $type;
                
            case 'ENUM':
            case 'SET':
                $values = array_map(fn($v) => "'" . addslashes($v) . "'", $column->enum_values);
                return "{$type}(" . implode(',', $values) . ")";
                
            case 'JSON':
            case 'GEOMETRY':
            case 'POINT':
            case 'LINESTRING':
            case 'POLYGON':
            case 'MULTIPOINT':
            case 'MULTILINESTRING':
            case 'MULTIPOLYGON':
            case 'GEOMETRYCOLLECTION':
                return $type;
                
            default:
                return $type;
        }
    }

    private function generateDefaultValue($default): string
    {
        if (is_string($default)) {
            return "'" . addslashes($default) . "'";
        }
        
        if (is_numeric($default)) {
            return (string)$default;
        }
        
        if (is_bool($default)) {
            return $default ? '1' : '0';
        }
        
        if ($default === null) {
            return 'NULL';
        }
        
        return "'" . addslashes($default) . "'";
    }

    private function generateIndexDefinition(Index $index): string
    {
        $sql = "";
        
        if ($index->unique) {
            $sql .= "UNIQUE ";
        }
        
        $sql .= "INDEX `{$index->name}` ";
        
        if ($index->type !== 'BTREE') {
            $sql .= "USING {$index->type} ";
        }
        
        $columns = array_map(function($col) {
            $def = "`{$col['column_name']}`";
            if (isset($col['length'])) {
                $def .= "({$col['length']})";
            }
            if (isset($col['order'])) {
                $def .= " {$col['order']}";
            }
            return $def;
        }, $index->columns);
        
        $sql .= "(" . implode(', ', $columns) . ")";
        
        if ($index->comment) {
            $sql .= " COMMENT '" . addslashes($index->comment) . "'";
        }
        
        return $sql;
    }

    private function generateForeignKeyDefinition(ForeignKey $foreignKey): string
    {
        $sql = "CONSTRAINT `{$foreignKey->name}` FOREIGN KEY (`" . 
               implode('`, `', $foreignKey->columns) . "`) ";
        
        $sql .= "REFERENCES `{$foreignKey->ref_table}` (`" . 
                implode('`, `', $foreignKey->ref_columns) . "`)";
        
        if ($foreignKey->on_delete) {
            $sql .= " ON DELETE {$foreignKey->on_delete}";
        }
        
        if ($foreignKey->on_update) {
            $sql .= " ON UPDATE {$foreignKey->on_update}";
        }
        
        return $sql;
    }

    private function generateCheckConstraintDefinition(CheckConstraint $check): string
    {
        $sql = "CONSTRAINT `{$check->name}` CHECK ({$check->expression})";
        
        if (isset($check->enforced) && !$check->enforced) {
            $sql .= " NOT ENFORCED";
        }
        
        return $sql;
    }

    private function generateTableOptions($options): string
    {
        $sqlParts = [];
        
        if ($options['engine']) {
            $sqlParts[] = "ENGINE={$options['engine']}";
        }
        
        if ($options['charset']) {
            $sqlParts[] = "DEFAULT CHARSET={$options['charset']}";
        }
        
        if ($options['collation']) {
            $sqlParts[] = "COLLATE={$options['collation']}";
        }
        
        if ($options['row_format']) {
            $sqlParts[] = "ROW_FORMAT={$options['row_format']}";
        }
        
        if ($options['auto_increment']) {
            $sqlParts[] = "AUTO_INCREMENT={$options['auto_increment']}";
        }
        
        if ($options['comment']) {
            $sqlParts[] = "COMMENT='" . addslashes($options['comment']) . "'";
        }
        
        return implode(' ', $sqlParts);
    }

    private function generatePartitioningDefinition(Partitioning $partitioning): string
    {
        $sql = "PARTITION BY ";
        
        switch ($partitioning->type) {
            case 'RANGE':
                $sql .= "RANGE ({$partitioning->expression})";
                break;
                
            case 'LIST':
                $sql .= "LIST ({$partitioning->expression})";
                break;
                
            case 'HASH':
                $sql .= "HASH ({$partitioning->expression})";
                break;
                
            case 'KEY':
                $sql .= "KEY (" . implode(',', $partitioning->columns) . ")";
                break;
        }
        
        if ($partitioning->partitions) {
            $sql .= " PARTITIONS {$partitioning->partitions}";
        }
        
        return $sql;
    }
}
```

---

## Laravel Architecture & Structure

### Directory Structure
```
app/
├── Http/
│   ├── Controllers/
│   │   └── Api/
│   │       └── V1/
│   │           ├── DatabaseController.php
│   │           ├── SchemaController.php
│   │           ├── TableController.php
│   │           ├── OperationController.php
│   │           └── DataController.php
│   ├── Middleware/
│   │   ├── SecurityMiddleware.php
│   │   ├── IdempotencyMiddleware.php
│   │   └── RateLimitMiddleware.php
│   └── Requests/
│       ├── CreateTableRequest.php
│       ├── UpdateTableRequest.php
│       ├── CreateColumnRequest.php
│       └── CreateIndexRequest.php
├── Models/
│   ├── Operation.php
│   ├── ChangeSet.php
│   ├── Table.php
│   ├── Column.php
│   ├── Index.php
│   ├── ForeignKey.php
│   └── CheckConstraint.php
├── Services/
│   ├── SqlGeneratorService.php
│   ├── ValidationService.php
│   ├── SecurityService.php
│   └── CapabilityService.php
├── Jobs/
│   ├── ProcessDdlOperation.php
│   └── ProcessDataOperation.php
└── Repositories/
    ├── TableRepository.php
    ├── SchemaRepository.php
    └── OperationRepository.php
```

### Service Provider Registration
```php
// app/Providers/AppServiceProvider.php
public function register()
{
    $this->app->singleton(SqlGeneratorService::class);
    $this->app->singleton(ValidationService::class);
    $this->app->singleton(SecurityService::class);
    $this->app->singleton(CapabilityService::class);
}
```

---

## Security Implementation

### Rate Limiting Implementation
```php
// app/Http/Middleware/RateLimitMiddleware.php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;

class RateLimitMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        $key = 'api:' . auth()->id() . ':' . $request->ip();
        
        // Different limits for different operation types
        $limits = [
            'schema_read' => 300, // per minute
            'ddl_preview' => 60,
            'ddl_apply' => 6,
            'data_browse' => 300,
        ];
        
        $operationType = $this->getOperationType($request);
        $limit = $limits[$operationType] ?? 100;
        
        if (RateLimiter::tooManyAttempts($key, $limit)) {
            return response()->json([
                'success' => false,
                'error' => [
                    'code' => 'RATE_LIMIT_EXCEEDED',
                    'message' => 'Too many requests',
                    'retry_after' => RateLimiter::availableIn($key)
                ]
            ], 429)->header('Retry-After', RateLimiter::availableIn($key));
        }
        
        RateLimiter::hit($key, 60); // 1 minute window
        
        $response = $next($request);
        
        $response->header('X-RateLimit-Limit', $limit);
        $response->header('X-RateLimit-Remaining', $limit - RateLimiter::attempts($key));
        
        return $response;
    }
    
    private function getOperationType(Request $request): string
    {
        if ($request->is('*/preview-sql')) {
            return 'ddl_preview';
        }
        
        if ($request->is('*/operations')) {
            return 'ddl_apply';
        }
        
        if ($request->is('*/data')) {
            return 'data_browse';
        }
        
        return 'schema_read';
    }
}
```

---

## Validation & Error Handling

### Form Request Implementation
```php
// app/Http/Requests/CreateTableRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use App\Services\ValidationService;

class CreateTableRequest extends FormRequest
{
    protected $validationService;

    public function __construct(ValidationService $validationService)
    {
        $this->validationService = $validationService;
    }

    public function authorize()
    {
        return true;
    }

    public function rules()
    {
        return [
            'name' => 'required|string|max:64|regex:/^[a-zA-Z_][a-zA-Z0-9_]*$/',
            'columns' => 'required|array|min:1',
            'columns.*.name' => 'required|string|max:64|regex:/^[a-zA-Z_][a-zA-Z0-9_]*$/',
            'columns.*.data_type' => 'required|string|in:' . implode(',', $this->validationService->getValidDataTypes()),
            'columns.*.nullable' => 'boolean',
            'columns.*.default' => 'nullable',
            'columns.*.auto_increment' => 'boolean',
            'columns.*.length' => 'nullable|integer|min:1|max:65535',
            'columns.*.precision' => 'nullable|integer|min:1|max:65',
            'columns.*.scale' => 'nullable|integer|min:0|max:30',
            'options.engine' => 'nullable|string|in:' . implode(',', $this->validationService->getValidEngines()),
            'options.charset' => 'nullable|string',
            'options.collation' => 'nullable|string',
        ];
    }

    public function withValidator($validator)
    {
        $validator->after(function ($validator) {
            $this->validationService->validateTableStructure($this->all(), $validator);
        });
    }
}
```

### Error Response Format
```php
// app/Http/Controllers/Controller.php
<?php

namespace App\Http\Controllers;

use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Foundation\Validation\ValidatesRequests;
use Illuminate\Routing\Controller as BaseController;

abstract class Controller extends BaseController
{
    use AuthorizesRequests, ValidatesRequests;

    protected function successResponse($data, $message = 'Success', $status = 200)
    {
        return response()->json([
            'success' => true,
            'data' => $data,
            'message' => $message,
            'timestamp' => now()->toISOString(),
            'request_id' => request()->header('X-Request-ID', uniqid())
        ], $status);
    }

    protected function errorResponse($code, $message, $details = null, $status = 400)
    {
        return response()->json([
            'success' => false,
            'error' => [
                'code' => $code,
                'message' => $message,
                'details' => $details
            ],
            'timestamp' => now()->toISOString(),
            'request_id' => request()->header('X-Request-ID', uniqid())
        ], $status);
    }

    protected function validationErrorResponse($errors, $message = 'Validation failed')
    {
        return $this->errorResponse('VALIDATION_ERROR', $message, $errors, 422);
    }

    protected function capabilityErrorResponse($feature, $requiredVersion)
    {
        return $this->errorResponse('CAPABILITY_UNSUPPORTED', 
            "Feature '{$feature}' requires MySQL {$requiredVersion} or higher", 
            ['feature' => $feature, 'required_version' => $requiredVersion], 
            409);
    }

    protected function ddlConflictErrorResponse($conflict, $details = null)
    {
        return $this->errorResponse('DDL_CONFLICT', 
            "DDL operation conflict: {$conflict}", 
            $details, 
            409);
    }
}
```

---

## Testing Strategy

### Feature Test Example
```php
// tests/Feature/DatabaseApiTest.php
<?php

namespace Tests\Feature;

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use App\Models\User;
use App\Models\Operation;

class DatabaseApiTest extends TestCase
{
    use RefreshDatabase;

    public function test_can_get_database_capabilities()
    {
        $user = User::factory()->create();
        
        $response = $this->actingAs($user)
            ->getJson('/api/v1/database/capabilities');
            
        $response->assertStatus(200)
            ->assertJsonStructure([
                'success',
                'data' => [
                    'version',
                    'capabilities',
                    'limits',
                    'engines'
                ]
            ]);
    }

    public function test_can_preview_sql_without_execution()
    {
        $user = User::factory()->create();
        
        $tableData = [
            'name' => 'test_table',
            'columns' => [
                [
                    'name' => 'id',
                    'data_type' => 'INT',
                    'auto_increment' => true,
                    'primary_key' => true
                ],
                [
                    'name' => 'name',
                    'data_type' => 'VARCHAR',
                    'length' => 255,
                    'nullable' => false
                ]
            ]
        ];
        
        $response = $this->actingAs($user)
            ->postJson('/api/v1/database/preview-sql', $tableData);
            
        $response->assertStatus(200)
            ->assertJsonStructure([
                'success',
                'data' => [
                    'sql',
                    'valid',
                    'errors'
                ]
            ]);
            
        $this->assertStringContains('CREATE TABLE', $response->json('data.sql'));
    }

    public function test_blocks_dangerous_operations()
    {
        $user = User::factory()->create();
        
        $response = $this->actingAs($user)
            ->postJson('/api/v1/database/preview-sql', [
                'sql' => 'DROP DATABASE test_db'
            ]);
            
        $response->assertStatus(403)
            ->assertJson([
                'success' => false,
                'error' => [
                    'code' => 'OPERATION_NOT_PERMITTED'
                ]
            ]);
    }

    public function test_idempotency_works()
    {
        $user = User::factory()->create();
        $idempotencyKey = 'test-key-' . uniqid();
        
        // First request
        $response1 = $this->actingAs($user)
            ->withHeaders(['Idempotency-Key' => $idempotencyKey])
            ->postJson('/api/v1/database/operations', [
                'type' => 'create_table',
                'payload' => ['name' => 'test_table']
            ]);
            
        // Second request with same key
        $response2 = $this->actingAs($user)
            ->withHeaders(['Idempotency-Key' => $idempotencyKey])
            ->postJson('/api/v1/database/operations', [
                'type' => 'create_table',
                'payload' => ['name' => 'test_table']
            ]);
            
        $this->assertEquals($response1->json(), $response2->json());
        $this->assertTrue($response2->headers->has('X-Idempotent'));
    }
}
```

---

## Deployment Checklist

### Pre-Deployment
- [ ] **Signature Verification System** implemented and tested with signal.avinertech.com
- [ ] **Tenant Security Middleware** implemented with blocking system
- [ ] **Admin Approval Workflow** implemented and tested
- [ ] **Operation Naming Service** implemented with auto-generation
- [ ] **Soft Delete System** implemented globally
- [ ] **Query Limits Service** implemented with dynamic limits
- [ ] **SOLID-Compliant Architecture** implemented
- [ ] **Security Middleware** implemented and tested
- [ ] **Least-privilege database user** created and configured
- [ ] **API versioning** (`/api/v1/`) implemented
- [ ] **Idempotency** middleware configured
- [ ] **Job queue** system configured (Redis/Database)
- [ ] **Rate limiting** implemented per operation type
- [ ] **Capability matrix** endpoint functional
- [ ] **SQL generator service** tested with all MySQL features
- [ ] **Error taxonomy** implemented with proper HTTP status codes
- [ ] **Audit logging** configured for all operations

### Database Setup
- [ ] **UI API user** created with restricted privileges
- [ ] **Operation cases table** created and seeded
- [ ] **Operation groups table** created for batch management
- [ ] **Enhanced operations table** created with tenant support
- [ ] **Tenant security logs table** created for violation tracking
- [ ] **Soft delete logs table** created for data recovery
- [ ] **Query limits table** created with default configurations
- [ ] **Signature verification logs table** created
- [ ] **Indexes** created on audit tables for performance
- [ ] **Connection pooling** configured
- [ ] **Backup strategy** implemented for audit data

### Tenant Management Setup
- [ ] **Tenant blocking system** configured
- [ ] **Security violation thresholds** set (3 violations = block)
- [ ] **Admin notification system** configured for tenant blocks
- [ ] **Tenant unblocking process** implemented
- [ ] **Tenant security monitoring** configured

### Batch Processing Setup
- [ ] **Admin approval workflow** configured
- [ ] **Batch operation queuing** implemented
- [ ] **Operation group management** implemented
- [ ] **Admin notification system** for pending approvals
- [ ] **Batch processing jobs** configured with proper timeouts

### Soft Delete System Setup
- [ ] **Global soft delete** implemented for all tables
- [ ] **Soft delete recovery** system implemented
- [ ] **Permanent deletion** system implemented
- [ ] **Soft delete logging** configured
- [ ] **Data retention policies** configured

### Monitoring & Observability
- [ ] **Structured logging** configured with request IDs
- [ ] **Performance metrics** collection enabled
- [ ] **Error tracking** (Sentry/Bugsnag) configured
- [ ] **Health checks** implemented for database connectivity
- [ ] **Rate limit monitoring** configured
- [ ] **DDL operation monitoring** with timeout alerts
- [ ] **Tenant security monitoring** configured
- [ ] **Signature verification monitoring** configured
- [ ] **Batch processing monitoring** configured
- [ ] **Soft delete monitoring** configured

### Security Verification
- [ ] **Signature verification** tested with signal service
- [ ] **Tenant blocking** tested with security violations
- [ ] **Admin approval workflow** tested end-to-end
- [ ] **Penetration testing** completed
- [ ] **SQL injection** testing passed
- [ ] **Rate limiting** tested under load
- [ ] **Authentication** flow tested
- [ ] **Authorization** rules verified
- [ ] **Audit trail** integrity verified
- [ ] **Soft delete security** verified

### Performance Testing
- [ ] **Batch processing** tested with large operation groups
- [ ] **Instant operations** tested with high concurrency
- [ ] **Query limits** tested with large datasets
- [ ] **Signature verification** tested under load
- [ ] **Database connection pooling** tested
- [ ] **Cache performance** tested
- [ ] **Queue processing** tested

### Integration Testing
- [ ] **Signal service integration** tested
- [ ] **Tenant microservice integration** tested
- [ ] **Admin notification system** tested
- [ ] **Batch approval workflow** tested
- [ ] **Soft delete recovery** tested
- [ ] **Operation naming** tested
- [ ] **Query limits enforcement** tested

---

## Conclusion

This implementation guide provides a comprehensive, **tenant-based, security-first approach** to building the MySQL Database Management API. The implementation addresses all critical requirements while maintaining **SOLID principles** and providing **admin approval workflows** for batch operations.

**Key Implementation Benefits:**

1. **Tenant-Based Operations** with signature verification and automatic tenant blocking
2. **Admin Approval Workflow** for batch operations with complete audit trail
3. **Auto-Generated Operation Naming** system for clear operation tracking
4. **Global Soft Delete System** with recovery and permanent deletion capabilities
5. **Dynamic Query Limits** based on table structure and operation type
6. **SOLID-Compliant Architecture** with proper separation of concerns
7. **Server-side security enforcement** prevents dangerous operations
8. **API versioning** ensures future compatibility
9. **Job-based DDL handling** prevents blocking operations
10. **Idempotency** ensures safe retries
11. **Capability matrix** enables version-specific features
12. **Comprehensive validation** prevents invalid operations
13. **Complete audit trail** provides operation history

**Architecture Highlights:**

- **3-Tier Operation System**: Fresh App DB, Modify/Enhance App DB, Data Operations
- **Batch vs Instant Processing**: DDL operations require admin approval, data operations execute instantly
- **Tenant Security**: Automatic blocking after 3 security violations
- **Signature Verification**: Integration with signal.avinertech.com for tenant authentication
- **Soft Delete Management**: Global implementation with recovery capabilities
- **Query Limits**: Dynamic limits based on table structure (≤3 columns: 1000 records, >3 columns: 100 records)

**Next Steps:**

1. **Implement P0 tasks** in order of priority
2. **Set up development environment** with proper database user and tenant system
3. **Configure signature verification** with signal.avinertech.com
4. **Create comprehensive test suite** covering all operation types
5. **Deploy to staging environment** for integration testing
6. **Perform security audit** before production deployment
7. **Configure admin approval workflow** and notification system

**Stability Measures:**

- **Circuit Breaker Pattern** for external service calls
- **Database Transaction Management** for batch operations
- **Queue Monitoring** with dead letter handling
- **Health Checks** for all external dependencies
- **Graceful Degradation** if signature service is unavailable
- **Comprehensive Error Handling** with proper HTTP status codes
- **Performance Monitoring** for all operation types

This implementation provides a **production-ready, enterprise-grade MySQL database management API** that balances security, functionality, maintainability, and tenant isolation while following SOLID principles and providing comprehensive audit capabilities.
